Check context switches of a process
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	You can view information about your process's context switches in /proc/<pid>/status.
	$ pid=307
	$ grep ctxt /proc/$pid/status
	voluntary_ctxt_switches:        41
	nonvoluntary_ctxt_switches:     16
	
Change entry point in c program
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	void hello_world()
	{
		printf("Hello world\n");
		//return 0;
		_exit(0);
	}
	/* 
		return type of entry function should be void
		it should end with _exit function
		compile it using gcc -e entry_point file.c
		The -e flag changes the address of the startup code. Startup code
		has the responsibility of returning to the OS again so it can perform its
		process cleanup code and other bookkeeping stuff. 
		The test() function simply returns;
		but there is no place to return to and hence the segmentation fault.
	*/	
	/*
		If you are on a system that provides GNU Binutils (like Linux), you can use
		the objcopy command to make an arbitrary function the new entry point.
		Suppose a file called program.c containing the entry function:

		$ cat > program.c
		#include <stdio.h>
		int entry()
		{
			return 0;
		}

		You first compile it using -c to generate a relocatable object file:
			$ gcc -c program.c -o program.o
		Then you redefine entry to be main:
			$ objcopy --redefine-sym entry=main program.o
		Now use gcc to compile the new object file:
			$ gcc program.o -o program

		NOTE: If your program already has a function
		called main, before step 2, you can do a
		separate objcopy invocation:
			objcopy --redefine-sym oldmain=main program.o
	*/

sturct bit
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* int a:3;
	/* 2: 00000010 (Select three two bit)
	 * 6: 00000110
	 * -6: 11111001+1=11111010 (2's comliment)
	 */
	* unsigned char : 0;
		The :0 field (0 width bit field) forces the next bit width member assignment to start from the next nibble. 

Struct 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Structure is a data type. You don't give values to a data type. You give values to instances/objects of data types.
	Below is not correct/not possible
	typedef struct
	{
		int id=0;
		char* name="none";
	}employee;

	// Do like below 
	typedef struct
	{
	   int id;
	   char* name;
	}employee;

	employee emp = {
		.id = 0 
		.name = "none"
	};
	
Define macro during compile time	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* -D Macro=10
	
Optimisation lavels
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* O0 - do not optmize
	* O1 - reduce code size & exectime
	* O2 - opimize even more all supported options that do not involve space speed trade off
	* O3 - simple function made inline
	* Os - designed fo reduce code but not reduce speed

Flags
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* -W - enable all the warnings during compilation
	* -Q - print each function name while compilation
	* -I - to include header file
		gcc -I ~/header/ file.c
	* -D - Define macro during compile time
		-D Macro=10
		-D Debug (gcc -D DEBUG file.c)
		#include<stdio.h>
		int main()
		{
			#ifndef DEBUG
				printf("Macro not defined\n");
			#else
				printf("Macro is Defined\n");
			#endif
		}

Static library creation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* gcc -c file.c -o file.o (file which fucntioality you want to include as lib)
	ar rcs libxyz.a file.o ....(*.o)
	gcc -static -o exe main.c -L. -lxyz
		ar - Archiever
		rcs - information when, what is updated
		libxyz.z - creating library
		exe - executable file or binary
		-L. - Current location
		-lxyz - xyz is your lib name
		
Shared library creation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* gcc -fPIC -c file.c
	gcc -shared -o libxyz.so *.o
	gcc -o main -L. -lxyz main.c
	export LD_LIBRARY_PATH=.
		The -fPIC option tells gcc to create position independant code which is necessary for shared libraries. 
		cc1: warning: -fPIC ignored for target (all code is position independent)
		It looks like -fPIC is not necessary on x86.
	
Gnu Debugger
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* compile with -g option 
		gcc -g file.c
	Run debugger 
		gdb ./a.out 
	set breakpoints
		b func1
		b func2
	run/r
	step/s
	* run time shell view
		shell ls
	* gdb -silent (No info about gdb)
	* to print source lines
		list line_num
		list function_name 
		list
	* information of breakpoints
		info breakpoints n (Information of n range breakpoints)
		info break n
	* delete breakpoints
		delete breakpoints n
		disable breakpoints n
	* watchpoint
		watch "expression"
		exporession - i==7
		watch i==7 (It will search whether i is global or in memory if not give error)
	* backtrace/bt	- to get decription of all stacks
	* frame/f - brief description of current line
	* q to exit program

sizeof 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* you cannot take the address of sizeof 
	* sizeof(a++) but a will not modify
		short x;
		printf("Sizeof macro = %d\n", sizeof(x)); ----- 2
		printf("Sizeof macro = %d\n", sizeof(x+1)); --- 4
	* printf("%d", (int)sizeof('A'));
		The sizeof operator will change the 'A' to its ASCII value and 
		to the sizeof operator that ASCII value is nothing but an integer.
	* sizeof("string") = 7
		The sizeof return the number of characters including the null character

Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
	* a[2][] - wrong
	* a[][2] - ok
		a[][2] = { {1,2}, {3,4}};
	Array is continous if column is fixed we can increase the row will not get problem
	
Free a block of memory previously allocated without using free	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* realloc(ptr, 0))
	
#define or enum
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	* Enum values can be automatically generated by compiler if we let it. 
		But all the define values are to be mentioned specifically. 
	* Macro is preprocessor, so unlike enum which is a compile time entity, source code has no idea about these macros. 
	So, the enum is better if we use a debugger to debug the code.
	* If we use enum values in a switch and the default case is missing, some compiler will give a warning.
	* Enum always makes identifiers of type int. But the macro let us choose between different integral types.
	* Macro does not specifically maintain scope restriction unlike enum. 
	
malloc(0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	* According to C standard, “ If the size of the space requested is zero, 
	the behavior is implementation defined: either a null pointer is returned, 
	or the behavior is as if the size were some nonzero value, 
	except that the returned pointer shall not be used to access an object”. 
	But there is a benefit of this. 
	The pointer return after malloc(0) will be valid pointer and can be deallocated using free() and it will not crash the program.

Operators Precedence	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	* https://cs50.harvard.edu/resources/cppreference.com/operator_precedence.html

Reading C type declarations	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	* http://unixwiz.net/techtips/reading-cdecl.html
	
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	


